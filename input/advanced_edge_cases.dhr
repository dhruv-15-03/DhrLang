// Advanced Edge Cases and Language Limits Testing
class AdvancedEdgeCases {
    static kaam main() {
        printLine("=== Advanced Edge Cases Testing ===");
        
        // Test 1: Deep recursion and stack limits
        try {
            num result = AdvancedEdgeCases.deepRecursion(1000);
            printLine("Deep recursion result: " + result);
        }
        catch(error) {
            printLine("Recursion error: " + error);
        }
        
        // Test 2: Large number operations
        printLine("\n--- Large Number Operations ---");
        num maxLong = 9223372036854775807;  // Maximum long value
        printLine("Max long value: " + maxLong);
        
        try {
            num overflow = maxLong + 1;  // This might overflow
            printLine("Overflow result: " + overflow);
        }
        catch(error) {
            printLine("Overflow error: " + error);
        }
        
        // Test 3: Floating point edge cases
        printLine("\n--- Floating Point Edge Cases ---");
        duo positiveInfinity = 1.0 / 0.0;
        duo negativeInfinity = -1.0 / 0.0;
        duo notANumber = 0.0 / 0.0;
        
        printLine("Positive infinity: " + positiveInfinity);
        printLine("Negative infinity: " + negativeInfinity);
        printLine("NaN: " + notANumber);
        
        // Test 4: String edge cases
        printLine("\n--- String Edge Cases ---");
        sab emptyString = "";
        sab nullChar = "\0";
        sab unicodeString = "Hello ‰∏ñÁïå üåç";
        
        printLine("Empty string length: " + emptyString.length());
        printLine("Null char string: '" + nullChar + "'");
        printLine("Unicode string: " + unicodeString);
        printLine("Unicode length: " + unicodeString.length());
        
        // Test 5: Array stress testing
        printLine("\n--- Array Stress Testing ---");
        try {
            num[] largeArray = new num[1000];
            for (num i = 0; i < arrayLength(largeArray); i++) {
                largeArray[i] = i * i;
            }
            printLine("Large array created: " + arrayLength(largeArray) + " elements");
            printLine("First element: " + largeArray[0]);
            printLine("Last element: " + largeArray[arrayLength(largeArray) - 1]);
        }
        catch(error) {
            printLine("Large array error: " + error);
        }
        
    // Test 6: Nested array access
        printLine("\n--- Nested Operations ---");
    // Multi-dimensional arrays not yet supported: placeholder future syntax (removed to keep file compiling)
    // num[][] matrix = new num[3][3];
        // Alternative approach:
        num[] row1 = [1, 2, 3];
        num[] row2 = [4, 5, 6];
        num[] row3 = [7, 8, 9];
        
        printLine("Matrix row 1: [" + row1[0] + ", " + row1[1] + ", " + row1[2] + "]");
        printLine("Matrix row 2: [" + row2[0] + ", " + row2[1] + ", " + row2[2] + "]");
        printLine("Matrix row 3: [" + row3[0] + ", " + row3[1] + ", " + row3[2] + "]");
        
        // Test 7: Complex boolean expressions
        printLine("\n--- Complex Boolean Logic ---");
        kya a = true;
        kya b = false;
        kya c = true;
        
        kya complex1 = (a && b) || (c && !b);
        kya complex2 = !(a && b) && (c || b);
        kya complex3 = ((a || b) && c) || (!a && !b);
        
        printLine("Complex expr 1: " + complex1);
        printLine("Complex expr 2: " + complex2);
        printLine("Complex expr 3: " + complex3);
        
        // Test 8: String manipulation limits
        printLine("\n--- String Manipulation Limits ---");
        sab baseString = "A";
        sab longString = baseString;
        
        // Build a moderately long string
        for (num i = 0; i < 10; i++) {
            longString = longString + longString;  // Exponential growth
        }
        printLine("Long string length: " + longString.length());
        
        // Test string methods on long string
        if (longString.length() > 0) {
            printLine("First char of long string: " + longString.charAt(0));
            printLine("Contains 'A': " + longString.contains("A"));
        }
        
        // Test 9: Mathematical function edge cases
        printLine("\n--- Math Function Edge Cases ---");
        printLine("sqrt(-1): " + sqrt(-1.0));  // Should be NaN
        printLine("log(0): " + log(0.0));      // Should be -Infinity
        printLine("pow(0, 0): " + pow(0.0, 0.0)); // Edge case
        
        // Test 10: Exception chaining
        printLine("\n--- Exception Chaining ---");
        try {
            AdvancedEdgeCases.chainedExceptions();
        }
        catch(finalError) {
            printLine("Final caught error: " + finalError);
        }
        
        // Test 11: Variable shadowing
        printLine("\n--- Variable Shadowing ---");
        num shadowVar = 100;
        printLine("Outer shadow var: " + shadowVar);
        
        if (true) {
            num shadowVar = 200;  // This should shadow the outer variable
            printLine("Inner shadow var: " + shadowVar);
        }
        printLine("Outer shadow var after block: " + shadowVar);
        
        // Test 12: Array boundary testing
        printLine("\n--- Array Boundary Testing ---");
        num[] boundaryArray = [10, 20, 30];
        
        try {
            // Test various boundary conditions
            printLine("Valid access [0]: " + boundaryArray[0]);
            printLine("Valid access [2]: " + boundaryArray[2]);
            
            // Invalid accesses
            num invalid1 = boundaryArray[-1];    // Negative index
            printLine("Should not reach here: " + invalid1);
        }
        catch(boundaryError) {
            printLine("Boundary error 1: " + boundaryError);
        }
        
        try {
            num invalid2 = boundaryArray[3];     // Index too high
            printLine("Should not reach here: " + invalid2);
        }
        catch(boundaryError2) {
            printLine("Boundary error 2: " + boundaryError2);
        }
        
        printLine("\n=== Edge Cases Testing Complete ===");
    }
    
    // Recursive function for testing stack limits
    static num deepRecursion(num n) {
        if (n <= 0) {
            return 0;
        }
        return n + AdvancedEdgeCases.deepRecursion(n - 1);
    }
    
    // Function to test exception chaining
    static kaam chainedExceptions() {
        try {
            throw "First exception";
        }
        catch(e1) {
            try {
                throw "Second exception in catch";
            }
            catch(e2) {
                throw "Final chained exception";
            }
        }
    }
}
