plugins {
    id 'java'
    id 'application'
    id 'jacoco'
    id 'maven-publish'
    id 'signing'
    id 'com.github.spotbugs' version '6.0.7'
    id 'checkstyle'
    id 'pmd'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'info.solidsoft.pitest' version '1.15.0'
}

group 'com.dhrlang'
version '1.1.2'
description 'DhrLang Programming Language - Modern static language (num/duo/sab/kya/kaam) with Hindi-inspired roots'

application {
    mainClass = 'dhrlang.Main'
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

dependencies {
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'
    testImplementation 'org.mockito:mockito-core:5.5.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.5.0'
    
    // JSON & schema validation for diagnostics contract test
    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.17.0'
    testImplementation 'com.networknt:json-schema-validator:1.4.0'
    
    // Code quality tools
    spotbugs 'com.github.spotbugs:spotbugs:4.8.3'
    spotbugsPlugins 'com.h3xstream.findsecbugs:findsecbugs-plugin:1.12.0'
    
    // Documentation
    implementation 'org.apache.commons:commons-lang3:3.13.0'
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
    withJavadocJar()
    withSourcesJar()
}

// Test configuration
test {
    useJUnitPlatform()
    maxHeapSize = "1G"
    // Force consistent encoding across platforms (Linux runners default to UTF-8; align Windows too)
    systemProperty 'file.encoding', 'UTF-8'
    jvmArgs '-Dfile.encoding=UTF-8'
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = 'full'
        showStandardStreams = false
    }
}

// Jacoco coverage
jacoco {
    toolVersion = "0.8.8"
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    finalizedBy jacocoTestCoverageVerification
}

jacocoTestCoverageVerification {
    // Baseline thresholds retained (will ratchet upwards Step 4 phases)
    // TODO(step4): raise gradually after adding focused tests; temporarily relaxed to avoid blocking while expanding suite
    violationRules {
        rule {
            element = 'BUNDLE'
            // Based on current Instruction ~49.8% (qualitySummary) and Branch ~33% (snapshot),
            // set conservative gates to prevent regressions while staying green.
            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.45
            }
            limit {
                counter = 'BRANCH'
                value = 'COVEREDRATIO'
                minimum = 0.30
            }
        }
    }
    // Skip coverage check if no exec data produced (e.g., running a filtered test class that ends up fully disabled)
    onlyIf {
        def execFile = file("$buildDir/jacoco/test.exec")
        return execFile.exists() && execFile.length() > 0
    }
}

task jacocoStrictCoverageVerification(type: JacocoCoverageVerification) {
    executionData fileTree(dir: "$buildDir/jacoco", includes: ["test.exec"]) 
    sourceSets sourceSets.main
    violationRules {
        rule {
            element = 'BUNDLE'
            limit { counter = 'LINE'; value = 'COVEREDRATIO'; minimum = 0.85 }
            limit { counter = 'BRANCH'; value = 'COVEREDRATIO'; minimum = 0.70 }
        }
    }
    onlyIf { false } 
}

spotbugs {
    toolVersion = '4.8.3'
    // Do not fail the build on SpotBugs findings or JDK invokedynamic missing class heuristics
    ignoreFailures = true
    // Allow analysis to proceed when certain synthetic runtime classes (e.g., makeConcatWithConstants) are not resolvable
    extraArgs = ['-allowMissingClasses']
}

spotbugsMain {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

// Checkstyle configuration
checkstyle {
    toolVersion = '10.12.1'
    configFile = file("config/checkstyle/checkstyle.xml")
    // Temporarily allow warnings without failing the build to get incremental cleanup
    // We'll re-tighten after formatting pass.
    ignoreFailures = true
    if (project.hasProperty('strictCheckstyle')) {
        ignoreFailures = false
        maxWarnings = 0
        maxErrors = 0
    }
}

checkstyleMain {
    source = 'src/main/java'
}

checkstyleTest {
    source = 'src/test/java'
}

// PMD configuration
pmd {
    toolVersion = '6.55.0'
    ruleSetFiles = files("config/pmd/ruleset.xml")
    ruleSets = []
    ignoreFailures = true // temporary soft-fail; use -PstrictPmd to re-enable failure
    if (project.hasProperty('strictPmd')) {
        ignoreFailures = false
    }
}

// Shadow JAR configuration (fat JAR)
shadowJar {
    archiveClassifier.set('')
    manifest {
        attributes(
            'Main-Class': 'dhrlang.Main',
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Implementation-Vendor': 'DhrLang Team'
        )
    }
}


tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
    options.compilerArgs += ['-Xlint:unchecked', '-Xlint:deprecation']
}

// Ensure Javadoc runs with UTF-8 to support Unicode box-drawing and emoji in strings/comments
tasks.withType(Javadoc) {
    options.encoding = 'UTF-8'
    options.charSet = 'UTF-8'
    if (options.respondsTo('docEncoding')) {
        options.docEncoding = 'UTF-8'
    }
    // Suppress strict doclint to avoid failures on generic angle brackets and emojis in comments
    options.addStringOption('Xdoclint:none', '-quiet')
    failOnError = false
}

// Publishing configuration
publishing {
    publications {
        maven(MavenPublication) {
            from components.java
            // Use lowercase artifactId to satisfy typical Maven repo conventions (may avoid 422 on GitHub Packages)
            artifactId = 'dhrlang'
            groupId = 'com.dhrlang'
            
            pom {
                name = 'DhrLang'
                description = 'Modern statically typed programming language (num/duo/sab/kya/kaam) with Hindi-inspired roots'
                url = 'https://github.com/dhruv-15-03/DhrLang'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                    }
                }
                
                developers {
                    developer {
                        id = 'dhruv-15-03'
                        name = 'Dhruv Rastogi'
                        email = 'dhruv.rastogi@example.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/dhruv-15-03/DhrLang.git'
                    developerConnection = 'scm:git:ssh://github.com:dhruv-15-03/DhrLang.git'
                    url = 'https://github.com/dhruv-15-03/DhrLang/tree/main'
                }
            }
        }
    }
    
    repositories {
        maven {
            name = "GitHubPackages"
            url = uri("https://maven.pkg.github.com/dhruv-15-03/DhrLang")
            credentials {
                // Priority: explicit gradle props > dedicated env vars > GitHub Actions defaults
                def user = project.findProperty("gpr.user") ?: System.getenv("GPR_USER") ?: System.getenv("GITHUB_ACTOR") ?: System.getenv("USERNAME")
                def token = project.findProperty("gpr.key")  ?: System.getenv("GPR_TOKEN") ?: System.getenv("GITHUB_TOKEN") ?: System.getenv("TOKEN")
                if(!user || !token) {
                    logger.lifecycle("[publish] Missing credentials (user=${user}, tokenPresent=${token!=null}). Publishing will fail unless provided.")
                }
                username = user
                password = token
            }
        }
    }
}

// Signing configuration (for Maven Central)
signing {
    required { gradle.taskGraph.hasTask("publish") }
    sign publishing.publications.maven
}

// Custom tasks
task integrationTest(type: Test) {
    description = 'Runs integration tests.'
    group = 'verification'
    
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath
    
    include '**/integration/**'
    
    shouldRunAfter test
}

tasks.register('generateErrorCodes') {
    group = 'verification'
    description = 'Generate ERROR_CODES.md from ErrorCode enum'
    doLast {
        def fileObj = file('src/main/java/dhrlang/error/ErrorCode.java')
        if(!fileObj.exists()) throw new GradleException('ErrorCode.java not found')
        def src = fileObj.text
        def matcher = (src =~ /enum\s+ErrorCode\s*\{([\s\S]*?)}/)
        if(!matcher.find()) throw new GradleException('Cannot parse ErrorCode enum')
        def body = matcher.group(1)
        def tokens = body.split(/[,\n]/)*.trim().findAll{ it && !it.startsWith('//') }
        def codes = tokens.collect{ it.replaceAll(/;.*/, '') }.findAll{ it }
        def md = new StringBuilder()
        md << '# Error Codes\n\n'
        md << 'Generated automatically. Edit descriptions below.\n\n'
        md << '| Code | Description |\n|------|-------------|\n'
        codes.sort().each { c -> md << "| ${c} | TODO: add description |\n" }
        file('ERROR_CODES.md').text = md.toString()
        println "Generated ERROR_CODES.md with ${codes.size()} codes"
    }
}

task runSample(type: JavaExec) {
    description = 'Runs sample DhrLang program'
    group = 'application'
    
    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'dhrlang.Main'
    args = ['input/sample.dhr']
}

task generateDocs(type: Javadoc) {
    description = 'Generates API documentation'
    group = 'documentation'
    
    source = sourceSets.main.allJava
    classpath = sourceSets.main.compileClasspath
    destinationDir = file('docs/api')
    
    options {
        encoding = 'UTF-8'
        charSet = 'UTF-8'
        author = true
        version = true
        windowTitle = "DhrLang API Documentation v${project.version}"
        docTitle = "DhrLang Programming Language API"
        header = "<b>DhrLang ${project.version}</b>"
    }
}


task packageDistribution(type: Zip) {
    description = 'Creates a complete distribution package'
    group = 'distribution'
    
    dependsOn build, shadowJar
    
    from('build/libs') {
        include '*.jar'
        into 'lib'
    }
    
    from('input') {
        include '*.dhr'
        into 'examples'
    }
    
    from('.') {
        include 'README.md', 'LICENSE', 'CHANGELOG.md'
    }
    
    from('docs') {
        into 'docs'
    }
    
    archiveFileName = "DhrLang-${project.version}-distribution.zip"
}

// Ensure build order
build.dependsOn shadowJar
check.dependsOn integrationTest, jacocoTestReport

// Explicitly declare dependencies to satisfy Gradle 8 task validation
tasks.named('distZip') { dependsOn shadowJar }
tasks.named('distTar') { dependsOn shadowJar }
tasks.named('startScripts') { dependsOn shadowJar }
tasks.named('startShadowScripts') { dependsOn jar }

// --- Mutation Testing (PIT) baseline configuration (Step 4) ---
pitest {
    pitestVersion = '1.15.0'
    junit5PluginVersion = '1.2.1'
    threads = 4
    timestampedReports = false
    targetClasses = [
        'dhrlang.eval.*',
        'dhrlang.typechecker.*',
        'dhrlang.runtime.*',
        'dhrlang.interpreter.*',
        'dhrlang.error.*'
    ]
    targetTests = ['dhrlang.*']
    excludedClasses = ['dhrlang.tools.*']
    outputFormats = ['HTML','XML']
    mutationThreshold = 0 // ratchet later
    coverageThreshold = 0
    avoidCallsTo = ['java.util.logging','org.slf4j','org.apache.log4j']
    verbose = false
}

// Aggregate quality summary (coverage + mutation) written to console
tasks.register('qualitySummary') {
    group = 'verification'
    description = 'Prints summary of test coverage and mutation score.'
    dependsOn 'test', 'jacocoTestReport', 'pitest'
    doLast {
        def jacocoXml = file("build/reports/jacoco/test/jacocoTestReport.xml")
        def instrCov = 'n/a'
        if(jacocoXml.exists()) {
            // Read text and remove DOCTYPE to avoid parser security restriction
            def text = jacocoXml.getText('UTF-8').replaceAll(/<!DOCTYPE[^>]*>/,'')
            def xml = new XmlParser(false,false).parseText(text)
            def counter = xml.counter.find { it.'@type'.toString() == 'INSTRUCTION' }
            if(counter) {
                def cov = (counter.'@covered'.toString().toBigDecimal())
                def miss = (counter.'@missed'.toString().toBigDecimal())
                def pct = miss + cov > 0 ? (cov * 100) / (cov + miss) : 0
                instrCov = String.format('%.2f', pct)
            }
        }
        def mutXml = file('build/reports/pitest/mutations.xml')
        def mutationScore = 'n/a'
        if(mutXml.exists()) {
            def mtext = mutXml.getText('UTF-8').replaceAll(/<!DOCTYPE[^>]*>/,'')
            def mxml = new XmlParser(false,false).parseText(mtext)
            def muts = mxml.mutation
            def total = muts.size()
            def killed = muts.findAll { it.'@status'.toString() in ['KILLED','TIMED_OUT','MEMORY_ERROR','RUN_ERROR'] }.size()
            if(total>0) mutationScore = String.format('%.2f', (killed*100.0)/total)
        }
        println "\n=== QUALITY SUMMARY ==="
        println "Instruction Coverage: ${instrCov}%"
        println "Mutation Score      : ${mutationScore}%"
        println "(Targets: raise thresholds & mutation score in subsequent Step 4 increments)"
    }
}

// Run style/bug-checkers only when explicitly enabled to keep default build fast and reliable
def qualityEnabled = project.hasProperty('enableQuality') && project.property('enableQuality') == 'true'
tasks.withType(Checkstyle).configureEach { onlyIf { qualityEnabled } }
tasks.withType(Pmd).configureEach { onlyIf { qualityEnabled } }
tasks.withType(com.github.spotbugs.snom.SpotBugsTask).configureEach { onlyIf { qualityEnabled } }

// --- Benchmark harness (lightweight) ---
// Usage: ./gradlew bench  (produces build/bench/bench-results.json)
tasks.register('bench') {
    group = 'verification'
    description = 'Runs micro benchmarks (interpreted) with --time and aggregates timings.'
    dependsOn 'build'
    doLast {
        def benchDir = file('bench')
        if(!benchDir.exists()) {
            println "No bench/ directory present; skipping benchmarks"
            return
        }
        def resultDir = file('build/bench'); resultDir.mkdirs()
        def results = []
        def shadowJar = file("build/libs/DhrLang-${project.version}.jar")
        benchDir.listFiles(new FilenameFilter(){ boolean accept(File d,String n){ n.endsWith('.dhr') } })?.each { f ->
            println "[bench] Running ${f.name}"
            def proc = ["java", "-jar", shadowJar.absolutePath, "--json", "--time", f.absolutePath].execute()
            def out = new StringWriter(); proc.waitForProcessOutput(out, System.err)
            def text = out.toString()
            // Extract JSON (first line that looks like JSON object)
            def jsonLine = text.readLines().find { it.trim().startsWith('{') && it.contains('"errors"') }
            if(!jsonLine) {
                println "[bench] WARN: No JSON line found for ${f.name}; raw output:\n${text}"
            } else {
                try {
                    def parsed = new groovy.json.JsonSlurper().parseText(jsonLine)
                    results << [file: f.name, timings: parsed.timings ?: [:], errorCount: (parsed.errors?.size() ?: 0)]
                } catch(Exception e) {
                    println "[bench] ERROR parsing JSON for ${f.name}: ${e.message}"
                }
            }
        }
        def outFile = new File(resultDir, 'bench-results.json')
        outFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(results))
        println "Benchmark results written to ${outFile}"
    }
}

// Ensure Spec version header matches project version (best-effort simple check)
tasks.register('verifySpecVersion') {
    group = 'verification'
    description = 'Verifies SPEC.md Version line matches project.version'
    doLast {
        def spec = file('SPEC.md')
        if(!spec.exists()) { throw new GradleException('SPEC.md not found') }
        def line = spec.readLines().find { it =~ /^Version:/ }
        if(!line) throw new GradleException('Version line not found in SPEC.md')
        def ver = (line.replaceFirst(/Version:\s*/, '').trim())
        if(!ver.startsWith(project.version.toString())) {
            throw new GradleException("SPEC.md version '${ver}' does not start with project version '${project.version}'")
        }
        println "[specVersion] SPEC.md version OK (${ver})"
    }
}
check.dependsOn 'verifySpecVersion'

// Generate SVG coverage badge from Jacoco XML (Instruction coverage)
tasks.register('generateCoverageBadge') {
    group = 'verification'
    description = 'Generates docs/badges/coverage.svg based on Jacoco instruction coverage.'
    dependsOn 'jacocoTestReport'
    doLast {
        def jacocoXml = file("build/reports/jacoco/test/jacocoTestReport.xml")
        if(!jacocoXml.exists()) { println "[coverageBadge] Jacoco report missing"; return }
        def text = jacocoXml.getText('UTF-8').replaceAll(/<!DOCTYPE[^>]*>/,'')
        def xml = new XmlParser(false,false).parseText(text)
        def counter = xml.counter.find { it.'@type'.toString() == 'INSTRUCTION' }
        if(!counter){ println "[coverageBadge] Instruction counter missing"; return }
        def cov = (counter.'@covered'.toString().toBigDecimal())
        def miss = (counter.'@missed'.toString().toBigDecimal())
        def pct = miss + cov > 0 ? (cov * 100) / (cov + miss) : 0
        def pctStr = String.format('%.1f', pct)
        String color = pct >= 80 ? '#4c1' : (pct >= 50 ? '#dfb317' : '#e05d44')
        def svg = """
<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"125\" height=\"20\" role=\"img\" aria-label=\"coverage:${pctStr}%\">\n  <linearGradient id=\"s\" x2=\"0\" y2=\"100%\"><stop offset=\"0\" stop-color=\"#bbb\" stop-opacity=\".1\"/><stop offset=\"1\" stop-opacity=\".1\"/></linearGradient>\n  <mask id=\"m\"><rect width=\"125\" height=\"20\" rx=\"3\" fill=\"#fff\"/></mask>\n  <g mask=\"url(#m)\"><rect width=\"70\" height=\"20\" fill=\"#555\"/><rect x=\"70\" width=\"55\" height=\"20\" fill=\"${color}\"/><rect width=\"125\" height=\"20\" fill=\"url(#s)\"/></g>\n  <g fill=\"#fff\" text-anchor=\"middle\" font-family=\"Verdana,Geneva,DejaVu Sans,sans-serif\" text-rendering=\"geometricPrecision\" font-size=\"110\">\n    <text aria-hidden=\"true\" x=\"355\" y=\"150\" fill=\"#010101\" fill-opacity=\".3\" transform=\"scale(.1)\" textLength=\"600\">coverage</text>\n    <text x=\"355\" y=\"140\" transform=\"scale(.1)\" fill=\"#fff\" textLength=\"600\">coverage</text>\n    <text aria-hidden=\"true\" x=\"965\" y=\"150\" fill=\"#010101\" fill-opacity=\".3\" transform=\"scale(.1)\" textLength=\"450\">${pctStr}%</text>\n    <text x=\"965\" y=\"140\" transform=\"scale(.1)\" fill=\"#fff\" textLength=\"450\">${pctStr}%</text>\n  </g>\n</svg>\n""".stripIndent()
        def outFile = file('docs/badges/coverage.svg')
        outFile.parentFile.mkdirs()
        outFile.text = svg
        println "[coverageBadge] Updated ${outFile} -> ${pctStr}%"
    }
}


